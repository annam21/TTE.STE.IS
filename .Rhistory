"2016-01-02 00:00:00"),
tz = "GMT"),
end = as.POSIXct(c("2016-01-05 00:00:00",
"2015-12-19 03:30:00",
"2016-01-01 05:00:00",
"2016-01-05 00:00:00"),
tz = "GMT"),
area = c(300, 200, 200, 450)
)
study_dates <- as.POSIXct(c("2016-01-01 00:00:00", "2016-01-04 23:59:59"), tz = "GMT")
occ <- build_occ(samp_freq = 3600, # seconds between the start of each sampling occasion
samp_length = 10, # duration of each sampling occasion (seconds)
study_start = study_dates[1],
study_end = study_dates[2])
eh <- ste_build_eh(df, deploy, occ)
n_bins <- 5
lambda <- 0.001
censor <- eh$censor[1]
cutoffs <- seq(0, censor, length.out = n_bins)
cutoffs
bin_data_raw <- map(eh$censor, gof_bins_var_int, lambda, n_bins)
gof_bins_var_int <- function(censor, lambda, n_bins){
# internal function to build bins at a single occasion
cutoffs <- seq(0, censor, length.out = n_bins)
out <- tibble(
bin = 1:n_bins,
left = cutoffs,
right = lead(cutoffs),
prob = exp_dens(left, right, lambda)
) %>%
mutate(prob = tidyr::replace_na(prob, replace = 1 - sum(prob, na.rm = T)))
return(out)
}
bin_data_raw <- map(eh$censor, gof_bins_var_int, lambda, n_bins)
exp_dens <- function(left, right, lambda){
pleft <- pexp(left, lambda); pright <- pexp(right, lambda)
out <- pright - pleft
return(out)
}
bin_data_raw <- map(eh$censor, gof_bins_var_int, lambda, n_bins)
bin_data_raw
build_gof_bins_var <- function(eh, n_bins, lambda){
# function to build bins for goodness of fit test with variable bin cutoffs
# for every occasion
# okay, so maybe it doesn't need to be it's own function.
# but it works like this, it matches the other function, and I want to go home
bin_data_raw <- map(eh$censor, gof_bins_var_int, lambda, n_bins)
return(bin_data_raw)
}
exp_dens <- function(left, right, lambda){
pleft <- pexp(left, lambda); pright <- pexp(right, lambda)
out <- pright - pleft
return(out)
}
gof_bins_var_int <- function(censor, lambda, n_bins){
# internal function to build bins at a single occasion
cutoffs <- seq(0, censor, length.out = n_bins)
out <- tibble(
bin = 1:n_bins,
left = cutoffs,
right = lead(cutoffs),
prob = exp_dens(left, right, lambda)
) %>%
mutate(prob = tidyr::replace_na(prob, replace = 1 - sum(prob, na.rm = T)))
return(out)
}
build_gof_bins_eq <- function(eh, nbins, lambda){
# function to build bins for goodness of fit test with bin cutoffs the same
# for every occasion
# bin probabilities vary between occasions when (cesnor < max(censor))
# highest observed censor value, used to set bins of = width
mx_cen <- max(eh$censor)
# define cutoff values between bins
cutoffs <- seq(0, mx_cen, length.out = n_bins)
bin_data_raw <- rep(
# initial bins, one df per occasion, bins adjusted later
list(
tibble(
bin = 1:n_bins,
left = cutoffs,
right = lead(cutoffs)
)
), nrow(eh)
) %>%
# set the max right cutoff for occasion[i] to the censor value[i]
map2(.,
as.list(eh$censor),
function(a,b){
out <- a %>%
mutate(right = replace(right, right > b, b))
return(out)
}
) %>%
# assign probabilities to each bin, each occasion, given lambda
map(.,
mutate,
prob = exp_dens(left, right, lambda)
) %>%
# set neg probs to 0 (adjust for censor value moving between occasions)
map(
.,
mutate,
prob = replace(prob, prob < 0, 0)
) %>%
# set final bin probability to 1 - sum of probabilities (i.e. the rest of the curve)
map(
.,
mutate,
prob = tidyr::replace_na(prob, replace = 1-sum(prob, na.rm = T))
)
return(bin_data_raw)
}
# scratch work
# Kenneth Loonam
# July 2020
#Recreate_vignette_objects======================================================
require(spaceNtime); require(dplyr); require(purrr)
df <- data.frame(
cam = c(1,1,2,2,2),
datetime = as.POSIXct(c("2016-01-02 12:00:00",
"2016-01-03 13:12:00",
"2016-01-02 12:00:00",
"2016-01-02 14:00:00",
"2016-01-03 16:53:42"),
tz = "GMT"),
count = c(1, 0, 0, 1, 2)
)
deploy <- data.frame(
cam = c(1, 2, 2, 2),
start = as.POSIXct(c("2015-12-01 15:00:00",
"2015-12-08 00:00:00",
"2016-01-01 00:00:00",
"2016-01-02 00:00:00"),
tz = "GMT"),
end = as.POSIXct(c("2016-01-05 00:00:00",
"2015-12-19 03:30:00",
"2016-01-01 05:00:00",
"2016-01-05 00:00:00"),
tz = "GMT"),
area = c(300, 200, 200, 450)
)
study_dates <- as.POSIXct(c("2016-01-01 00:00:00", "2016-01-04 23:59:59"), tz = "GMT")
occ <- build_occ(samp_freq = 3600, # seconds between the start of each sampling occasion
samp_length = 10, # duration of each sampling occasion (seconds)
study_start = study_dates[1],
study_end = study_dates[2])
eh <- ste_build_eh(df, deploy, occ)
n_bins <- 5
lambda <- 0.001
build_gof_bins_eq(eh, 5, 0.001)
build_gof_bins_var(eh, 5, 0.001)
build_gof_bins_eq(eh, 5, 0.001)
build_gof_bins_eq(eh, 5, 0.001)
build_gof_bins_var(eh, 5, 0.001)
#Recreate_vignette_objects======================================================
require(spaceNtime); require(dplyr); require(purrr); require(assertr)
bin_cuts <- "equal"
assertr::assert(in_set("equal", "variable"), bin_cuts)
assertr::verify(in_set("equal", "variable"), bin_cuts)
?verify
assertr::verify(bin_cuts == "equal" | bin_cuts == "variable")
assertr::verify(bin_cuts, bin_cuts == "equal" | bin_cuts == "variable")
?stopifnot
assertr::assert(bin_cuts == "equal" | bin_cuts == "variable")
?stop
# scratch work
# Kenneth Loonam
# July 2020
#Recreate_vignette_objects======================================================
require(spaceNtime); require(dplyr); require(purrr); require(assertr)
df <- data.frame(
cam = c(1,1,2,2,2),
datetime = as.POSIXct(c("2016-01-02 12:00:00",
"2016-01-03 13:12:00",
"2016-01-02 12:00:00",
"2016-01-02 14:00:00",
"2016-01-03 16:53:42"),
tz = "GMT"),
count = c(1, 0, 0, 1, 2)
)
deploy <- data.frame(
cam = c(1, 2, 2, 2),
start = as.POSIXct(c("2015-12-01 15:00:00",
"2015-12-08 00:00:00",
"2016-01-01 00:00:00",
"2016-01-02 00:00:00"),
tz = "GMT"),
end = as.POSIXct(c("2016-01-05 00:00:00",
"2015-12-19 03:30:00",
"2016-01-01 05:00:00",
"2016-01-05 00:00:00"),
tz = "GMT"),
area = c(300, 200, 200, 450)
)
study_dates <- as.POSIXct(c("2016-01-01 00:00:00", "2016-01-04 23:59:59"), tz = "GMT")
occ <- build_occ(samp_freq = 3600, # seconds between the start of each sampling occasion
samp_length = 10, # duration of each sampling occasion (seconds)
study_start = study_dates[1],
study_end = study_dates[2])
eh <- ste_build_eh(df, deploy, occ)
n_bins <- 5
lambda <- 0.001
eh
assertr::assert
?assertr::assert
assertr::assert(has_all_names(occ, start, end, STE, censor))
assertr::assert(has_all_names("occ", "start", "end", "STE", "censor"))
eh %>%
assertr::assert(has_all_names("occ", "start", "end", "STE", "censor"))
eh %>%
assertr::assert(has_all_names(occ, start, end, STE, censor))
?has_all_names
eh %>%
assertr::verify(has_all_names("occ", "start", "end", "STE", "censor"))
names(eh) <- c("ralf", "bob", "end", "STE", "censor")
eh %>%
assertr::verify(has_all_names("occ", "start", "end", "STE", "censor"))
?verify
help("success_and_error_functions")
?error_stop
eh %>%
assertr::verify(
has_all_names("occ", "start", "end", "STE", "censor"),
error_fun = function()print("eh must be a data frame with columns occ, start, end, STE, and censor"))
?assertthat
??assertthat
install.packages("assertthat")
assertthat::assert_that(is.df(eh))
assertthat::assert_that(is.data.frame(eh))
assertthat::assert_that(is.data.frame(n_bins))
?has_all_names
assertthat::assert_that(
assertr::verify(eh,
assertr::has_all_names("occ", "start", "end", "STE", "censor"), success_fun = success_logical))
assertthat::assert_that(
assertr::verify(eh,
assertr::has_all_names("occ", "start", "end", "STE", "censor"), success_fun = success_logical), error_fun = error_logical)
?assertthat::assert_that
assertthat::assert_that(
assertr::verify(eh,
assertr::has_all_names("occ", "start", "end", "STE", "censor"),
success_fun = success_logical,
error_fun = error_logical),
msg = "eh must be a dataframe with columns occ, start, end, STE and censor")
assertthat::assert_that(is.numeric(lambda), length(lambda == 1), lambda > 0)
lambda
is.numeric(lambda)
assertthat::assert_that(is.numeric(lambda), length(lambda) == 1, lambda > 0)
lambda <- -2
assertthat::assert_that(is.numeric(lambda), length(lambda) == 1, lambda > 0)
assertthat::assert_that(
is.numeric(lambda),
length(lambda) == 1,
lambda > 0,
msg = "lambda must be a single numeric value greater than 0")
is.vector(lambda)
assertthat::assert_that(
is.integer(n_bins),
is.vector(n_bins),
n_bins > 0,
msg = "n_bins must be a vector of positive integers"
)
n_bins
is.integer(n_bins)
1%/%5
5%/%1
5.5%/%1
?`%/%`
5%%1
5.5%%1
assertthat::assert_that(
n_bins%%1 == 0,
is.vector(n_bins),
n_bins > 0,
msg = "n_bins must be a vector of positive integers"
)
n_bins <- 5.5
assertthat::assert_that(
n_bins%%1 == 0,
is.vector(n_bins),
n_bins > 0,
msg = "n_bins must be a vector of positive integers"
)
n_bins <- c(5.5, 6)
assertthat::assert_that(
n_bins%%1 == 0,
is.vector(n_bins),
n_bins > 0,
msg = "n_bins must be a vector of positive integers"
)
assertthat::assert_that(
all(n_bins%%1 == 0),
is.vector(n_bins),
n_bins > 0,
msg = "n_bins must be a vector of positive integers"
)
n_bins <- c(5, 6)
assertthat::assert_that(
all(n_bins%%1 == 0),
is.vector(n_bins),
n_bins > 0,
msg = "n_bins must be a vector of positive integers"
)
assertthat::assert_that(
all(n_bins%%1 == 0),
is.vector(n_bins),
all(n_bins > 0),
msg = "n_bins must be a vector of positive integers"
)
# scratch work
# Kenneth Loonam
# July 2020
#Recreate_vignette_objects======================================================
require(spaceNtime); require(dplyr); require(purrr); require(assertr)
df <- data.frame(
cam = c(1,1,2,2,2),
datetime = as.POSIXct(c("2016-01-02 12:00:00",
"2016-01-03 13:12:00",
"2016-01-02 12:00:00",
"2016-01-02 14:00:00",
"2016-01-03 16:53:42"),
tz = "GMT"),
count = c(1, 0, 0, 1, 2)
)
deploy <- data.frame(
cam = c(1, 2, 2, 2),
start = as.POSIXct(c("2015-12-01 15:00:00",
"2015-12-08 00:00:00",
"2016-01-01 00:00:00",
"2016-01-02 00:00:00"),
tz = "GMT"),
end = as.POSIXct(c("2016-01-05 00:00:00",
"2015-12-19 03:30:00",
"2016-01-01 05:00:00",
"2016-01-05 00:00:00"),
tz = "GMT"),
area = c(300, 200, 200, 450)
)
study_dates <- as.POSIXct(c("2016-01-01 00:00:00", "2016-01-04 23:59:59"), tz = "GMT")
occ <- build_occ(samp_freq = 3600, # seconds between the start of each sampling occasion
samp_length = 10, # duration of each sampling occasion (seconds)
study_start = study_dates[1],
study_end = study_dates[2])
eh <- ste_build_eh(df, deploy, occ)
n_bins <- 5
lambda <- 0.001
n_bins <- c(2,3,5)
bin_cuts <- "equal"
# Build bin data, throw error if bin_cuts are not correctly defined
if(bin_cuts == "equal"){
bin_data <- build_gof_bins_eq(eh, n_bins, lambda)
}else{
if(bin_cuts == "variable"){
bin_data <- build_gof_bins_var(eh, n_bins, lambda)
}else{
stop("bin_cuts must be the words `equal` or `positive` as a character")
}
}
build_gof_bins_eq <- function(eh, n_bins, lambda){
# function to build bins for goodness of fit test with bin cutoffs the same
# for every occasion
# bin probabilities vary between occasions when (cesnor < max(censor))
# highest observed censor value, used to set bins of = width
mx_cen <- max(eh$censor)
# define cutoff values between bins
cutoffs <- seq(0, mx_cen, length.out = n_bins)
bin_data_raw <- rep(
# initial bins, one df per occasion, bins adjusted later
list(
tibble(
bin = 1:n_bins,
left = cutoffs,
right = lead(cutoffs)
)
), nrow(eh)
) %>%
# set the max right cutoff for occasion[i] to the censor value[i]
map2(.,
as.list(eh$censor),
function(a,b){
out <- a %>%
mutate(right = replace(right, right > b, b))
return(out)
}
) %>%
# assign probabilities to each bin, each occasion, given lambda
map(.,
mutate,
prob = exp_dens(left, right, lambda)
) %>%
# set neg probs to 0 (adjust for censor value moving between occasions)
map(
.,
mutate,
prob = replace(prob, prob < 0, 0)
) %>%
# set final bin probability to 1 - sum of probabilities (i.e. the rest of the curve)
map(
.,
mutate,
prob = tidyr::replace_na(prob, replace = 1-sum(prob, na.rm = T))
)
return(bin_data_raw)
}
build_gof_bins_var <- function(eh, n_bins, lambda){
# function to build bins for goodness of fit test with variable bin cutoffs
# for every occasion
# okay, so maybe it doesn't need to be it's own function.
# but it works like this, it matches the other function, and I want to go home
bin_data_raw <- map(eh$censor, gof_bins_var_int, lambda, n_bins)
return(bin_data_raw)
}
source("R\\build_gof_bins_eq.R"); source("R\\build_gof_bins_var.R")
source("R\\gof_bins_bar_int.R")
source("R\\gof_bins_var_int.R")
# Build bin data, throw error if bin_cuts are not correctly defined
if(bin_cuts == "equal"){
bin_data <- build_gof_bins_eq(eh, n_bins, lambda)
}else{
if(bin_cuts == "variable"){
bin_data <- build_gof_bins_var(eh, n_bins, lambda)
}else{
stop("bin_cuts must be the words `equal` or `positive` as a character")
}
}
source("R\\gof_bins_var_int.R"); source("R\\exponential_density.R")
# Build bin data, throw error if bin_cuts are not correctly defined
if(bin_cuts == "equal"){
bin_data <- build_gof_bins_eq(eh, n_bins, lambda)
}else{
if(bin_cuts == "variable"){
bin_data <- build_gof_bins_var(eh, n_bins, lambda)
}else{
stop("bin_cuts must be the words `equal` or `positive` as a character")
}
}
bin_data
# scratch work
# Kenneth Loonam
# July 2020
#Recreate_vignette_objects======================================================
require(spaceNtime); require(dplyr); require(purrr); require(assertr)
df <- data.frame(
cam = c(1,1,2,2,2),
datetime = as.POSIXct(c("2016-01-02 12:00:00",
"2016-01-03 13:12:00",
"2016-01-02 12:00:00",
"2016-01-02 14:00:00",
"2016-01-03 16:53:42"),
tz = "GMT"),
count = c(1, 0, 0, 1, 2)
)
deploy <- data.frame(
cam = c(1, 2, 2, 2),
start = as.POSIXct(c("2015-12-01 15:00:00",
"2015-12-08 00:00:00",
"2016-01-01 00:00:00",
"2016-01-02 00:00:00"),
tz = "GMT"),
end = as.POSIXct(c("2016-01-05 00:00:00",
"2015-12-19 03:30:00",
"2016-01-01 05:00:00",
"2016-01-05 00:00:00"),
tz = "GMT"),
area = c(300, 200, 200, 450)
)
study_dates <- as.POSIXct(c("2016-01-01 00:00:00", "2016-01-04 23:59:59"), tz = "GMT")
occ <- build_occ(samp_freq = 3600, # seconds between the start of each sampling occasion
samp_length = 10, # duration of each sampling occasion (seconds)
study_start = study_dates[1],
study_end = study_dates[2])
eh <- ste_build_eh(df, deploy, occ)
n_bins <- 2
lambda <- 0.001
bin_cuts <- "equal"
source("R\\build_gof_bins_eq.R"); source("R\\build_gof_bins_var.R")
source("R\\gof_bins_var_int.R"); source("R\\exponential_density.R")
# Build bin data, throw error if bin_cuts are not correctly defined
if(bin_cuts == "equal"){
bin_data <- build_gof_bins_eq(eh, n_bins, lambda)
}else{
if(bin_cuts == "variable"){
bin_data <- build_gof_bins_var(eh, n_bins, lambda)
}else{
stop("bin_cuts must be the words `equal` or `positive` as a character")
}
}
bin_data
n_bins <- 5
# Build bin data, throw error if bin_cuts are not correctly defined
if(bin_cuts == "equal"){
bin_data <- build_gof_bins_eq(eh, n_bins, lambda)
}else{
if(bin_cuts == "variable"){
bin_data <- build_gof_bins_var(eh, n_bins, lambda)
}else{
stop("bin_cuts must be the words `equal` or `positive` as a character")
}
}
n_bins
bin_data
?between
# Build bin data, throw error if bin_cuts are not correctly defined
if(bin_cuts == "equal"){
bin_data <- build_gof_bins_eq(eh, n_bins, lambda)
}else{
if(bin_cuts == "variable"){
bin_data <- build_gof_bins_var(eh, n_bins, lambda)
}else{
stop("bin_cuts must be the words `equal` or `positive` as a character")
}
}
