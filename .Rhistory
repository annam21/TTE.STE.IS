# Build effort for each cam at each occasion
tictoc::tic("effort")
eff <- effort_fn(deploy_s, occ)
tictoc::toc()
# Calculate the censors
tictoc::tic("calculate censors")
censor <- ste_calc_censor(eff)
tictoc::toc()
df<-df_s;effort<-eff
# Calculate the lowest common denominator for samp_freq
ss <- lcd_fn(occ)
# Find sampling occasions where counts exist
# This captures any count within the occasion. Later, I take only the first
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
select(occ, cam, count)
count_at_occ
tmp <- effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam")) %>%
# Here NAs are pictures that didn't exist. 0s are counts of 0
# count should be NA if area = 0.
# Find the area until the first count, at each occcasion
mutate(STE = cumsum(area)) %>%
# If the area is 0, it's just adding 0 to the STE. That's good.
filter(count > 0) %>%
# Here I'm filtering NAs too, so if a photo doesn't exist, its count is 0
filter(!duplicated(occ)) %>%
# Add back NAs on all other sampling occasions
select(occ, STE) %>%
left_join(occ, ., by = "occ")
tmp
effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n())
effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam"))
tmp<-effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam"))
tmp %>% filter(!is.na(count))
tmp <- effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam")) %>%
# Here NAs are pictures that didn't exist. 0s are counts of 0
# count should be NA if area = 0.
# Find the area until the first count, at each occcasion
mutate(STE = cumsum(area))
tmp %>% filter(!is.na(count))
tmp %>% filter(!is.na(count))%>%as.data.frame()
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
# Take only the first at each camera
filter(!duplicated(occ, cam))
count_at_occ
count_at_occ%>%as.data.frame
tmp <- effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam")) %>%
# Here NAs are pictures that didn't exist. 0s are counts of 0
# count should be NA if area = 0.
# Find the area until the first count, at each occasion
mutate(STE = cumsum(area)) %>%
# If the area is 0, it's just adding 0 to the STE. That's good.
filter(count > 0) %>%
# Here I'm filtering NAs too, so if a photo doesn't exist, its count is 0
filter(!duplicated(occ)) %>%
# Add back NAs on all other sampling occasions
select(occ, STE) %>%
left_join(occ, ., by = "occ")
# Find sampling occasions where counts exist
# This captures any count within the occasion. Later, I take only the first
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
# Take only the first at each camera
# filter(!duplicated(occ, cam)) %>%
select(occ, cam, count)
tmp <- effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam")) %>%
# Here NAs are pictures that didn't exist. 0s are counts of 0
# count should be NA if area = 0.
# Find the area until the first count, at each occasion
mutate(STE = cumsum(area)) %>%
# If the area is 0, it's just adding 0 to the STE. That's good.
filter(count > 0) %>%
# Here I'm filtering NAs too, so if a photo doesn't exist, its count is 0
filter(!duplicated(occ)) %>%
# Add back NAs on all other sampling occasions
select(occ, STE) %>%
left_join(occ, ., by = "occ")
head(tmp)
tmp%>%filter(!is.na(STE))
tmp <- effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam")) %>%
# Here NAs are pictures that didn't exist. 0s are counts of 0
# count should be NA if area = 0.
# Find the area until the first count, at each occasion
mutate(STE = cumsum(area)) %>%
# If the area is 0, it's just adding 0 to the STE. That's good.
filter(count > 0)
head(count_at_occ)
tmp <- effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam")) %>%
# Here NAs are pictures that didn't exist. 0s are counts of 0
# count should be NA if area = 0.
# Find the area until the first count, at each occasion
mutate(STE = cumsum(area)) %>%
# If the area is 0, it's just adding 0 to the STE. That's good.
filter(count > 0) %>%
# Here I'm filtering NAs too, so if a photo doesn't exist, its count is 0
filter(!duplicated(occ))
head(count_at_occ)
count_at_occ
head(tmp)
head(tmp)%>%as.data.frame()
tmp <- effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam")) %>%
# Here NAs are pictures that didn't exist. 0s are counts of 0
# count should be NA if area = 0.
# Find the area until the first count, at each occasion
mutate(STE = cumsum(area))
head(tmp)%>%as.data.frame()
# Find sampling occasions where counts exist
# This captures any count within the occasion. Later, I take only the first
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
# Take only the first at each camera
filter(!duplicated(occ, cam)) %>%
select(occ, cam, count)
count_at_occ
??duplicated
# Find sampling occasions where counts exist
# This captures any count within the occasion. Later, I take only the first
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
# Take only the first at each camera
distinct(occ, cam) %>%
select(occ, cam, count)
# Find sampling occasions where counts exist
# This captures any count within the occasion. Later, I take only the first
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
# Take only the first at each camera
distinct(occ, cam, .keep_all = T) %>%
select(occ, cam, count)
count_at_occ
# Find sampling occasions where counts exist
# This captures any count within the occasion. Later, I take only the first
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
# Take only the first at each camera at each occasion
distinct(occ, cam, .keep_all = T) %>%
select(occ, cam, count)
count_at_occ
tmp <- effort %>%
# Randomly order cameras at each occasion
group_by(occ) %>%
sample_n(n()) %>%
# Join up our counts
left_join(., count_at_occ, by = c("occ", "cam")) %>%
# Here NAs are pictures that didn't exist. 0s are counts of 0
# count should be NA if area = 0.
# Find the area until the first count, at each occasion
mutate(STE = cumsum(area)) %>%
# If the area is 0, it's just adding 0 to the STE. That's good.
filter(count > 0) %>%
# Here I'm filtering NAs too, so if a photo doesn't exist, its count is 0
filter(!duplicated(occ)) %>%
# Add back NAs on all other sampling occasions
select(occ, STE) %>%
left_join(occ, ., by = "occ")
head(tmp)
tmp%>%filter(!is.na(STE))
# Do it with rounding instead of intervals!!!
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(effort, ., by = c("start" = "nearestpos", "cam")) %>%
select(occ, cam, count)
# Do it with rounding instead of intervals!!!
count_at_occ
# Find sampling occasions where counts exist
# This captures any count within the occasion. Later, I take only the first
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
# Take only the first at each camera at each occasion
distinct(occ, cam, .keep_all = T) %>%
select(occ, cam, count)
# This captures any count within the occasion. Later, I take only the first
count_at_occ
df %>%
filter(count > 0)
df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
)
# Do it with rounding instead of intervals!!!
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(effort, ., by = c("start" = "nearestpos", "cam")) %>%
select(occ, cam, count) %>%
distinct(occ, cam, .keep_all = T)
count_at_occ
# Do it with rounding instead of intervals!!!
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(effort, ., by = c("start" = "nearestpos", "cam")) %>%
select(occ, cam, count) %>%
filter(!is.na(count))
count_at_occ
# Do it with rounding instead of intervals!!!
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(effort, ., by = c("start" = "nearestpos", "cam")) %>%
select(occ, cam, count) %>%
filter(!is.na(count)) %>%
distinct(occ, cam, .keep_all = T)
count_at_occ
df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam")
df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
)
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(., effort, by = c("start" = "nearestpos", "cam"))
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(., effort, by = c("nearestpos" = "start", "cam"))
count_at_occ
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(., effort, by = c("nearestpos" = "start", "cam")) %>%
select(occ, cam, count)
count_at_occ
# Do it with rounding instead of intervals!!!
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(., effort, by = c("nearestpos" = "start", "cam")) %>%
select(occ, cam, count) %>%
distinct(occ, cam, .keep_all = T)
count_at_occ
count_at_occ <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(., effort, by = c("nearestpos" = "start", "cam"))
head(count_at_occ)
head(effort)
tz(effort$start)
lubridate:;tz(effort$start)
lubridate::tz(effort$start)
count_at_occ <- df %>%
filter(count > 0)
head(count_at_occ)
xx <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
)
head(xx)
ss
xx$nearestpos+40000
xx$nearestpos[1]+40000
head(xx)
head(occ)
occ
xx <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
left_join(., effort, by = c("nearestpos" = "start", "cam"))
head(xx)
xx <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
# Join by the start time of that interval
left_join(., effort, by = c("nearestpos" = "start", "cam")) %>%
# But then keep only if within the end date of that interval
filter(datetime <= end)
xx
xx <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
# Join by the start time of that interval
left_join(., effort, by = c("nearestpos" = "start", "cam")) %>%
# But then keep only if within the end date of that interval
filter(datetime <= end) %>%
select(occ, cam, count)
xx
# Do it with rounding instead of intervals!!!
xx <- df %>%
filter(count > 0) %>%
# round down to the nearest interval
mutate(timefromfirst = as.numeric(datetime) - as.numeric(min(effort$start)),
nearest = plyr::round_any(timefromfirst, ss, f = floor),
nearestpos = as.POSIXct(nearest,
origin = min(effort$start),
tz = lubridate::tz(effort$start))
) %>%
# Join by the start time of that interval
left_join(., effort, by = c("nearestpos" = "start", "cam")) %>%
# But then keep only if within the end date of that interval
filter(datetime <= end) %>%
select(occ, cam, count) %>%
# Only keep the first one at each camera on each occasion
distinct(occ, cam, .keep_all = T)
xx
# Find sampling occasions where counts exist
# This captures any count within the occasion. Later, I take only the first
count_at_occ <- df %>%
filter(count > 0) %>%
left_join(effort, .,  by = "cam") %>%
filter(datetime %within% int) %>%
# Take only the first at each camera at each occasion
distinct(occ, cam, .keep_all = T) %>%
select(occ, cam, count)
count_at_occ
library(tidyverse)
devtools::load_all(".")
load("../CameraTrapStudy/2015 data/pics.wide20160804.RData")
# Make dataframe
df <- pics %>%
select(cam, timeGMT, elkpresent) %>%
filter(elkpresent == T) %>%
mutate(count = as.numeric(elkpresent)
) %>%
rename(datetime = timeGMT)
# Make a pretend deploy, as if all always working
deploy <- pics %>%
distinct(cam, op.start, op.end) %>%
# fix problem child
mutate(op.start = replace(op.start, cam == "AM158", "2016-01-05 17:00:00") ) %>%
mutate(start = as.POSIXct(op.start),
start = lubridate::force_tz(start, "GMT"),
end = as.POSIXct(op.end),
end = lubridate::force_tz(end, "GMT"),
area = 250
) %>%
select(-op.start, -op.end)
study_dates <- as.POSIXct(c("2016-01-01 01:04:18", "2016-03-27 00:00:00"),
tz = "GMT")
# Now actually use the package
occ <- build_occ(samp_freq = 40000,
samp_length = 1,
study_start = study_dates[1],
study_end = study_dates[2])
ste_eh <- ste_build_eh(df, deploy, occ)
# Now actually use the package
occ <- build_occ(samp_freq = 30,
samp_length = 1,
study_start = study_dates[1],
study_end = study_dates[2])
ste_eh <- ste_build_eh(df, deploy, occ)
# Fail if a camera took a photo but that time is not in deploy
# Very similar function to find_overlap. Work on that in future
pic_in_deploy <- left_join(df, deploy) %>%
mutate(wthn = datetime >= start & datetime <= end) %>%
group_by(cam) %>%
summarise(allgood = any(wthn)) %>%
filter(allgood == F | is.na(allgood))
head(df)
head(deploy)
# Now actually use the package
occ <- build_occ(samp_freq = 4000,
samp_length = 1,
study_start = study_dates[1],
study_end = study_dates[2])
devtools::load_all(".")
ste_eh <- ste_build_eh(df, deploy, occ)
